#+TITLE: Solutions
#+startup: content
#+options: header-args:asm :tangle no

Consultar também: http://ref.x86asm.net/index.html
E também: http://ref.x86asm.net/coder-abc.html
E também: https://web.itu.edu.tr/kesgin/mul06/intel/index.html

[[https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start][Guia rápido dos registradores]].

E o [[https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/nios2/n2cpu_nii51017.pdf][Instruction Set Reference]]. Que também pode ser encontrado [[https://www.felixcloutier.com/x86/][aqui]].

* Debug

Antes de mais  nada, lembre-se de *executar apenas código  no qual você
confia*.

*Não me responsabilizo se algo aqui causar danos ao seu computador.*

Para debugar, recomendo usar o próprio programa ~GDB~, através do editor
Emacs, que tem um modo só para  isso e permite ver as variáveis locais
e registradores através de ~gdb-display-locals-buffer~.

Caso você não use Emacs, use o programa ~DDD~ em conjunto com ~GDB~.

Meu assembler favorito é ~nasm~, então também o recomendo.

Vou adicionar um Makefile que ajuda com isso.

#+begin_src makefile :tangle Makefile
SRC := $(wildcard *.asm)
BIN := $(SRC:%.asm=%.out)

.PHONY: clear

all: $(BIN)

%.out: %.o
	ld -m elf_x86_64 $^ -o $@

%.o: %.asm
	nasm -felf64 -Fdwarf $^ -o $@

clear:
	rm -f *.o *.out
#+end_src

Ao início, é interessante adicionar o seguinte:

#+name: asm_prelude
#+begin_src asm :tangle no
	global	_start
	section	.text
_start:
#+end_src

* 0x00

#+name: 0x00
#+begin_src asm
	xor	eax,eax	; 1. eax <- zero, já que X xor X = 0
	lea	rbx,[0]	; 2. rbx <- endereço de memória 0
	loop	$	; 3. rcx <- rcx - 1. Se rcx <> 0, JMP para
			; instrução atual. Em outras palavras,
			; loop decrementando rcx até que rcx = 0
	mov	rdx,0	; 4. rdx <- 0, sem surpresas
	and	esi,0	; 5. esi <- 0, já que X and 0 = 0
	sub	edi,edi	; 6. edi <- 0, já que X - X = 0
	push	0	; 7. Dá push em 0 na pilha...
	pop	rbp	; ...e dá pop no 0 que está no topo da
			; pilha, diretamente para rbp.
#+end_src

O algoritmo  acima mostra várias  formas de zerar  registradores, mais
especificamente zerando ~eax~, ~rbx~, ~rcx~, ~rdx~, ~esi~, ~edi~ e ~rbp~.

** Notas

Em   geral,  registradores   começados  com   E  são   registradores
extendidos  (32 bits).   Os  começados com  R  são similares,  porém
usados em contextos de 64 bits.

#+begin_example
0x1122334455667788
  ================ rax (64 bits)
          ======== eax (32 bits)
              ====  ax (16 bits)
              ==    ah (8 bits)
                ==  al (8 bits)
#+end_example

- ~[X]~: local apontado por ~X~.
- ~XOR A,B~: ~A <- A ^ B~
- ~LEA A,[B]~:  Parece ~MOV~, mas ~A  <- B~. Comparativamente, ~MOV~  faz ~A <-
  *[B]~.
- ~RCX~: Geralmente usado como contador/índice mesmo.
- ~EDX~: Geralmente usado  como auxiliar e como extensor  de precisão de
  ~EAX~.  Por  exemplo, um  número  grande  pode ser  armazenado  usando
  ~EDX:EAX~.
- ~LOOP LABEL~: Decrementa ~RCX~. Se ~RCX~ não for igual a zero, dá ~JMP~ para
  ~LABEL~.
- ~ESI~: Source  Index (extendido). Registrador  não-volátil normalmente
  usado   para  armazenar   ponteiros.  Aponta   para  a   "fonte",  o
  "início". Imagine armazenar o endereço  de uma string que está sendo
  copiada para a memória.
- ~EDI~:  Destination  Index  (extendido). Complementa  ~ESI~;  imagine  o
  endereço para onde a string está sendo copiada na memória.
- ~RBP~: Ponteiro base para a pilha (64 bits).

* 0x01

#+name: 0x01
#+begin_src asm
.loop:
	xadd	rax,rdx ; temp <- rax + rdx, rdx <- rax, rax <- temp
	loop	.loop	; Itera decrementando rcx até rcx = 0
#+end_src

Este é  o algoritmo  para calcular  o N-ésimo  número da  sequência de
Fibonacci, de forma iterativa.

O algoritmo usa ~rax~ como resultado atual, e ~rdx~ como acumulador para o
resultado anterior. ~rcx~ determina o valor de N.

** Notas

O prelúdio  a seguir  fará com  que o valor  remanescente ao  final da
execução, em ~rax~, seja ~8~:

#+begin_src asm :tangle 01.asm :noweb yes
<<asm_prelude>>
	mov	rax,1
	mov	rdx,0
	mov	rcx,5
<<0x01>>
#+end_src

Isso faz com que iniciemos a sequência ~0~,  ~1~, ~1~, ~2~, ~3~, ~5~, ~8~, tal que a
contagem se inicie a partir do primeiro ~1~.

Recomenda-se iniciar com  o seguinte prelúdio para  termos a sequência
de Lucas ao invés de Fibonacci:

#+begin_src asm
	mov	rax,2
	mov	rdx,1
	mov	rcx,N ; trocar N pelo número designado
#+end_src

* 0x02

#+name: 0x02
#+begin_src asm
	neg	rax	; cf = (rax == 0) ? 0 : 1. Nega o valor de rax.
	sbb	rax,rax	; rax <- (cf == 1) ? -1 : 0
	neg	rax	; veja acima
#+end_src

O código  toma o valor  de ~rax~ e, com  base em operações  envolvendo a
/carry flag/ do registrador, define ~rax~ como ~1~ se seu valor anterior era
diferente de zero. Caso contrário, define ~rax~ como ~0~.

** Notas

- ~sbb dest,src~  => "Integer subtraction  with borrow". ~dest <-  dest -
  (src + cf)~.
- O primeiro  ~neg~ define a  /carry flag/ de  ~rax~ como ~0~  se ~rax =  0~. Do
  contrário, a /carry flag/ recebe ~1~. Além disso, claro, alterna o sinal
  do valor em ~rax~.
- A segunda instrução define ~rax~ como ~-1~  se a /carry flag/ é igual a ~1~;
  do contrário, define ~rax~ como ~0~.
- O segundo  ~neg~ modifica a /carry  flag/ como apontado acima,  mas aqui
  tem o papel de inverter o sinal de ~rax~ quando ~rax = -1~.

Em teoria, a segunda e a terceira instruções poderiam ser substituídas
por ~jnc~ se  a intenção é realizar /branching/ em  seguida -- por exemplo,
imagine a situação de um /jmp/ caso ~rax~ seja igual a zero:

#+begin_src asm
	neg	rax		; Código original
	sbb	rax,rax		;
	neg	rax		;
	test	rax,rax		; zf = (rax == 0) ? 1 : 0
	jz	algum_label	; pula para algum_label se zf == 1
#+end_src

Código equivalente:

#+begin_src asm
	neg	rax
	jnc	algum_label
#+end_src

- ~jnc label~ => "Jump if not carry". /jmp/ para ~label~ se ~cf~ é igual a ~0~.
- ~test  a,b~ =>  "Logical compare".  Realiza AND  lógico entre  ~a~ e  ~b~;
  descarta  o resultado;  define as  flags  ~sf~, ~zf~  e  ~pf~ com  ~1~ ou  ~0~
  dependendo do resultado.

* 0x03

#+name: 0x03
#+begin_src asm
	sub	rdx,rax	; rdx <- rdx - rax.
			;     cf <- Se rax > rdx, 1. Senão, 0.
	sbb	rcx,rcx	; rcx <- Se cf = 0, 0. Senão, -1
	and	rcx,rdx	; rcx <- Se rcx = 0, 0. Senão, rdx
	add	rax,rcx	; rax <- rax + rcx
#+end_src

O  código  compara   e  retorna  o  menor  valor  entre   ~rdx~  e  ~rax~,
armazenando-o em ~rax~ ao  final. Funciona especificamente entre valores
/unsigned/.

** Notas

- Em ~sub a,b~, ~cf <- 1~ se e somente se ~unsigned(b) > unsigned(a)~.
  Isso é conhecido  como um /borrow/ (tomar emprestado), como  se faz em
  uma  operação de  subtração. Em  geral  isso não  demonstra nada  em
  especial numa  subtração de números  com sinal, mas indica  erros em
  operações com valores /unsigned/.
- Se  valores negativos  forem  atribuídos  a ~rdx~  ou  a ~rax~,  deve-se
  considerar  sua  representação  binária  como  complemento  de  dois
  -- =~(x  - 0b1)=  --,  o  que se  tornará  um número  exorbitantemente
  grande.
- O  uso de  ~sbb~  é similar  ao desafio  anterior,  onde utiliza-se  a
  instrução com um mesmo registrador  para armazenar o oposto da /carry
  flag/.  Nesse caso,  o valor  (~-1~  ou ~0~)  serve como  uma espécie  de
  "seletor" do valor armazenado em ~rdx~;  como o complemento de dois de
  ~-1~ é uma máscara onde todos os  bits são ~1~, ~and rcx,rdx~ fará com que
  o valor de ~rdx~  seja armazenado em ~rcx~ sem necessidade  de um ~mov~ ou
  uma comparação extra. Caso contrário, um valor ~0~ em ~rcx~ fará com que
  o ~and~ retorne zeros em todos os bits, efetivamente colocando o valor
  ~0~ em ~rcx~.
  
* 0x04

#+name: 0x04
#+begin_src asm
	xor	al,0x20
#+end_src

O algoritmo alterna  o sexto bit de  ~al~ (contando de LSB  como sendo o
primeiro, da direita para a esquerda). Consequentemente, isso equivale
a somar ou subtrair o valor ~32~ do número representado por ~al~.

** Notas

- ~0x20~ = ~32~ = ~0010 0000~

* 0x05

#+name: 0x05
#+begin_src asm
	sub	rax,5
	cmp	rax,4
#+end_src

Subtrai ~5~ de ~rax~, armazenando o resultado em ~rax~, e em seguida compara
se  ~rax~  é  igual a  ~4~.  Em  suma,  compara  se  ~rax~ era  igual  a  ~9~,
originalmente.

Acredito  que o  propósito  aqui seja  demonstrar,  através de  estudo
aprofundado,  que  em essência,  ~sub~  e  ~cmp~  realizam a  exata  mesma
operação, subtraindo o segundo operando do primeiro e definindo ~EFLAGS~
de acordo com o resultado.

Todavia,  ~cmp~   não  modifica   seu  primeiro  operando   (~rax~,  nesse
caso). Dessa forma, a única saída de relevância na execução de ~cmp~ é a
flag ~zf~.

** Notas

#+begin_src asm :tangle 05.asm :noweb yes
<<asm_prelude>>
	mov	rax,9
<<0x05>>
	mov	rax,9
	sub	rax,5
	sub	rax,4
#+end_src

- ~cmp~  realiza uma  operação similar  a ~sub~,  porém, não  modifica seu
  primeiro  operando.  A  comparação portanto  realiza  uma  subtração
  ~op1 -  op2~, definindo ~EFLAGS~ como  ~sub~ o faria. Nesse  caso, a saída
  mais importante  de ~cmp~  está na flag  ~ZF~, ativa se  e somente  se o
  resultado da operação for igual a zero.
- ~sub~ também define ~eflags~, da mesma  forma como ~cmp~ faz. Assim, ~cmp~ é
  definitivamente  uma especialização  de ~sub~  que não  altera um  dos
  operandos, podendo ser mais rápido dependendo de tais operandos.
  
* 0x06

#+name: 0x06
#+begin_src asm
	not	rax	; Bitwise NOT
	inc	rax 	; Incrementa
	neg	rax	; Nega
#+end_src

Esse código apenas mostra como  números /signed/ são, na verdade, apenas
números  /unsigned/ interpretados  levando  em consideração  a regra  do
complemento de dois para números negativos. ~not~ e ~inc~ realizam o exato
mesmo comportamento de  ~neg~ que, executado em seguida,  retorna ~rax~ ao
seu valor inicial.

Em geral, o complemento de dois  de um número corresponde a realizar o
complemento de  um do mesmo número  (~not~), e então somar  um (~inc~). Em
outras palavras, a combinação das instruções  ~not~ e ~inc~ levam ao mesmo
comportamento  de ~neg~;  o  ~neg~  ao final  apenas  calcula novamente  o
complemento de dois de ~rax~.

** Notas

|---------+-------+--------------+---------|
| opcode  | sinal | magnitude    | decimal |
|---------+-------+--------------+---------|
| inicial |     0 | 000 0010     |      +2 |
|---------+-------+--------------+---------|
| ~not~     |     1 | 111 1101     |      -3 |
|---------+-------+--------------+---------|
| ~inc~     |     1 | 111 1110     |      -2 |
|---------+-------+--------------+---------|
| ~neg~     |     0 | 000 0001 + 1 |         |
|         |     0 | 000 0010     |      +2 |
|---------+-------+--------------+---------|

Exemplo debugável:

#+begin_src asm :tangle 06.asm :noweb yes
<<asm_prelude>>
	mov	rax,9
<<0x06>>
#+end_src

- ~inc~ de fato incrementa um número,  mas isso deve ser considerado com
  certa crítica: como números inteiros com sinal, em computadores, são
  armazenados através de  complemento de dois, em  teoria, não existem
  números com sinal, muito menos números negativos. Isso significa que
  ~inc~ realiza um incremento em  um número necessariamente /unsigned/, no
  fim das contas.
- A instrução  ~set $rax =  X~ do  GDB me ajudou  aqui a perceber  o que
  estava acontecendo.


