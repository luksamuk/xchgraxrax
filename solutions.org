#+TITLE: Solutions
#+startup: content
#+options: header-args:asm :tangle no

Consultar também: http://ref.x86asm.net/index.html
E também: http://ref.x86asm.net/coder-abc.html
E também: https://web.itu.edu.tr/kesgin/mul06/intel/index.html

[[https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start][Guia rápido dos registradores]].

E o [[https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/nios2/n2cpu_nii51017.pdf][Instruction Set Reference]]. Que também pode ser encontrado [[https://www.felixcloutier.com/x86/][aqui]].

* Debug

Antes de mais  nada, lembre-se de *executar apenas código  no qual você
confia*.

*Não me responsabilizo se algo aqui causar danos ao seu computador.*

Para debugar, recomendo o programa ~DDD~ em conjunto com ~GDB~.

Meu assembler favorito é ~nasm~, então também o recomendo.

Vou adicionar um Makefile que ajuda com isso.

#+begin_src makefile :tangle Makefile
SRC := $(wildcard *.asm)
BIN := $(SRC:%.asm=%.out)

.PHONY: clear

all: $(BIN)

%.out: %.o
	ld -m elf_x86_64 $^ -o $@

%.o: %.asm
	nasm -felf64 -Fdwarf $^ -o $@

clear:
	rm -f *.o *.out
#+end_src

Ao início, é interessante adicionar o seguinte:

#+name: asm_prelude
#+begin_src asm :tangle no
	global	_start
	section	.text
_start:
#+end_src

E ao final:

#+name: asm_ending
#+begin_src asm :tangle no
	
	int	0x80	; chamar o kernel para retorno
#+end_src

Ao  abrir  o programa  no  ~ddd~,  lembre-se  de usar  adequadamente  os
breakpoints e o watcher de registradores (~Status > Registers...~).

* 0x00

#+name: 0x00
#+begin_src asm
	xor	eax,eax	; 1. eax <- zero, já que X xor X = 0
	lea	rbx,[0]	; 2. rbx <- endereço de memória 0
	loop	$	; 3. rcx <- rcx - 1. Se rcx <> 0, JMP para
			; instrução atual. Em outras palavras,
			; loop decrementando rcx até que rcx = 0
	mov	rdx,0	; 4. rdx <- 0, sem surpresas
	and	esi,0	; 5. esi <- 0, já que X and 0 = 0
	sub	edi,edi	; 6. edi <- 0, já que X - X = 0
	push	0	; 7. Dá push em 0 na pilha...
	pop	rbp	; ...e dá pop no 0 que está no topo da
			; pilha, diretamente para rbp.
#+end_src

O algoritmo  acima mostra várias  formas de zerar  registradores, mais
especificamente zerando ~eax~, ~rbx~, ~rcx~, ~rdx~, ~esi~, ~edi~ e ~rbp~.

** Notas

Em   geral,  registradores   começados  com   E  são   registradores
extendidos  (32 bits).   Os  começados com  R  são similares,  porém
usados em contextos de 64 bits.

#+begin_example
0x1122334455667788
  ================ rax (64 bits)
          ======== eax (32 bits)
              ====  ax (16 bits)
              ==    ah (8 bits)
                ==  al (8 bits)
#+end_example

- ~[X]~: local apontado por ~X~.
- ~XOR A,B~: ~A <- A ^ B~
- ~LEA A,[B]~:  Parece ~MOV~, mas ~A  <- B~. Comparativamente, ~MOV~  faz ~A <-
  *[B]~.
- ~RCX~: Geralmente usado como contador/índice mesmo.
- ~EDX~: Geralmente usado  como auxiliar e como extensor  de precisão de
  ~EAX~.  Por  exemplo, um  número  grande  pode ser  armazenado  usando
  ~EDX:EAX~.
- ~LOOP LABEL~: Decrementa ~RCX~. Se ~RCX~ não for igual a zero, dá ~JMP~ para
  ~LABEL~.
- ~ESI~: Source  Index (extendido). Registrador  não-volátil normalmente
  usado   para  armazenar   ponteiros.  Aponta   para  a   "fonte",  o
  "início". Imagine armazenar o endereço  de uma string que está sendo
  copiada para a memória.
- ~EDI~:  Destination  Index  (extendido). Complementa  ~ESI~;  imagine  o
  endereço para onde a string está sendo copiada na memória.
- ~RBP~: Ponteiro base para a pilha (64 bits).

* 0x01

#+name: 0x01
#+begin_src asm
.loop:
	xadd	rax,rdx ; temp <- rax + rdx, rdx <- rax, rax <- temp
	loop	.loop	; Itera decrementando rcx até rcx = 0
#+end_src

Este é  o algoritmo  para calcular  o N-ésimo  número da  sequência de
Fibonacci, de forma iterativa.

O algoritmo usa ~rax~ como resultado atual, e ~rdx~ como acumulador para o
resultado anterior. ~rcx~ determina o valor de N.

** Notas

O prelúdio  a seguir  fará com  que o valor  remanescente ao  final da
execução, em ~rax~, seja ~8~:

#+begin_src asm :tangle 01.asm
<<asm_prelude>>
	mov	rax,1
	mov	rdx,0
	mov	rcx,5
<<0x01>>
<<asm_ending>>
#+end_src

Isso faz com que iniciemos a sequência ~0~,  ~1~, ~1~, ~2~, ~3~, ~5~, ~8~, tal que a
contagem se inicie a partir do primeiro ~1~.

Recomenda-se iniciar com  o seguinte prelúdio para  termos a sequência
de Lucas ao invés de Fibonacci:

#+begin_src asm
	mov	rax,2
	mov	rdx,1
	mov	rcx,N ; trocar N pelo número designado
#+end_src

* 0x02

#+name: 0x02
#+begin_src asm
	neg	rax	; cf = (rax == 0) ? 0 : 1. Nega o valor de rax.
	sbb	rax,rax	; rax <- (cf == 1) ? -1 : 0
	neg	rax	; veja acima
#+end_src

O código  toma o valor  de ~rax~ e, com  base em operações  envolvendo a
/carry flag/ do registrador, define ~rax~ como ~1~ se seu valor anterior era
diferente de zero. Caso contrário, define ~rax~ como ~0~.

** Notas

- ~sbb dest,src~  => "Integer subtraction  with borrow". ~dest <-  dest -
  (src + cf)~.
- O primeiro  ~neg~ define a  /carry flag/ de  ~rax~ como ~0~  se ~rax =  0~. Do
  contrário, a /carry flag/ recebe ~1~. Além disso, claro, alterna o sinal
  do valor em ~rax~.
- A segunda instrução define ~rax~ como ~-1~  se a /carry flag/ é igual a ~1~;
  do contrário, define ~rax~ como ~0~.
- O segundo  ~neg~ modifica a /carry  flag/ como apontado acima,  mas aqui
  tem o papel de inverter o sinal de ~rax~ quando ~rax = -1~.

Em teoria, a segunda e a terceira instruções poderiam ser substituídas
por ~jnc~ se  a intenção é realizar /branching/ em  seguida -- por exemplo,
imagine a situação de um /jmp/ caso ~rax~ seja igual a zero:

#+begin_src asm
	neg	rax		; Código original
	sbb	rax,rax		;
	neg	rax		;
	test	rax,rax		; zf = (rax == 0) ? 1 : 0
	jz	algum_label	; pula para algum_label se zf == 1
#+end_src

Código equivalente:

#+begin_src asm
	neg	rax
	jnc	algum_label
#+end_src

- ~jnc label~ => "Jump if not carry". /jmp/ para ~label~ se ~cf~ é igual a ~0~.
- ~test  a,b~ =>  "Logical compare".  Realiza AND  lógico entre  ~a~ e  ~b~;
  descarta  o resultado;  define as  flags  ~sf~, ~zf~  e  ~pf~ com  ~1~ ou  ~0~
  dependendo do resultado.

* 0x03

#+name: 0x03
#+begin_src asm
	sub	rdx,rax	; rdx <- rdx - rax.
			;     cf <- Se rax > rdx, 1. Senão, 0.
	sbb	rcx,rcx	; rcx <- Se cf = 0, 0. Senão, -1
	and	rcx,rdx	; rcx <- Se rcx = 0, 0. Senão, rdx
	add	rax,rcx	; rax <- rax + rcx
#+end_src

O  código  compara   e  retorna  o  menor  valor  entre   ~rdx~  e  ~rax~,
armazenando-o em ~rax~ ao  final. Funciona especificamente entre valores
/unsigned/.

** Notas

- Em ~sub a,b~, ~cf <- 1~ se e somente se ~unsigned(b) > unsigned(a)~.
  Isso é conhecido  como um /borrow/ (tomar emprestado), como  se faz em
  uma  operação de  subtração. Em  geral  isso não  demonstra nada  em
  especial numa  subtração de números  com sinal, mas indica  erros em
  operações com valores /unsigned/.
- Se  valores negativos  forem  atribuídos  a ~rdx~  ou  a ~rax~,  deve-se
  considerar  sua  representação  binária  como  complemento  de  dois
  -- =~(x  - 0b1)=  --,  o  que se  tornará  um número  exorbitantemente
  grande.
- O  uso de  ~sbb~  é similar  ao desafio  anterior,  onde utiliza-se  a
  instrução com um mesmo registrador  para armazenar o oposto da /carry
  flag/.  Nesse caso,  o valor  (~-1~  ou ~0~)  serve como  uma espécie  de
  "seletor" do valor armazenado em ~rdx~;  como o complemento de dois de
  ~-1~ é uma máscara onde todos os  bits são ~1~, ~and rcx,rdx~ fará com que
  o valor de ~rdx~  seja armazenado em ~rcx~ sem necessidade  de um ~mov~ ou
  uma comparação extra. Caso contrário, um valor ~0~ em ~rcx~ fará com que
  o ~and~ retorne zeros em todos os bits, efetivamente colocando o valor
  ~0~ em ~rcx~.
  
